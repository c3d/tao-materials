// Materials module definition
//
// This module defines the materials primitives
//
// Copyright 2010-2011 Taodyne

module_description
    id "a5ae8295-dbe5-416d-abca-8fc4551f36c5"
    name "Materials"
    import_name "Materials"
    description "A module to add different materials in a scene."
    author "Taodyne SAS"
    website "http://www.taodyne.com"
    version "1.0"

module_description "fr",
    name "Filtrage"
    description "Permet d'appliquer différents matériaux sur des objets présent dans une scène."

SHADER4_AVAILABLE_MATERIALS -> true
SHADER4_AVAILABLE_MATERIALS := is_ext_available "GL_EXT_gpu_shader4"

import Mapping 1.0

// -------------------------------------------------------------------------------------------------------------------
//   PLASTIC MATERIAL
// -------------------------------------------------------------------------------------------------------------------

// Plastic color
PLASTIC_R -> 1.0
PLASTIC_R := 1.0
PLASTIC_G -> 1.0
PLASTIC_G := 1.0
PLASTIC_B -> 1.0
PLASTIC_B := 1.0

plastic r:real, g:real, b:real ->
    /**
    * Apply plastic material.
    **/
    PLASTIC_R := r
    PLASTIC_G := g
    PLASTIC_B := b
    if SHADER4_AVAILABLE_MATERIALS = false then
        plastic_shader_no_lights
    else
        plastic_shader_lights

plastic_shader_lights ->
    /**
    * Define plastic shader with a full support of lights.
    **/
    shader_program
        vertex_shader <<
            varying float ratio;
            uniform vec3 camera;
            uniform mat4 modelMatrix;

            varying vec3 viewDir;
            varying vec3 normal;
            void main()
            {
               mat3 normalMatrix;

               // First column
               normalMatrix[0][0] = modelMatrix[0][0];
               normalMatrix[0][1] = modelMatrix[0][1];
               normalMatrix[0][2] = modelMatrix[0][2];

               // Second column
               normalMatrix[1][0] = modelMatrix[1][0];
               normalMatrix[1][1] = modelMatrix[1][1];
               normalMatrix[1][2] = modelMatrix[1][2];

               // Third column
               normalMatrix[2][0] = modelMatrix[2][0];
               normalMatrix[2][1] = modelMatrix[2][1];
               normalMatrix[2][2] = modelMatrix[2][2];

               gl_Position = ftransform();

               // World-space lighting
               normal   =  normalize(normalMatrix * gl_Normal);
               viewDir  = -normalize((modelMatrix * gl_Vertex).xyz);

               vec3 eyePos   = normalize(camera + viewDir);
               ratio = 0.5 * (1.0 + dot(eyePos, normal));

               normal   =  normalize(gl_NormalMatrix * gl_Normal);
               viewDir  = -normalize((gl_ModelViewMatrix * gl_Vertex).xyz);
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require
            #extension GL_EXT_gpu_shader4 : enable

            uniform int  lights;
            uniform vec3 color;

            varying float ratio;
            varying vec3  viewDir;
            varying vec3  normal;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                // Define a maximum of lights supported
                int MAX_LIGHTS = 8;

                vec4 lighting_color;
                if(lights > 0)
                {
                    vec3 N = normalize(normal);
                    vec3 V = normalize(viewDir);

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient  = gl_FrontLightModelProduct.sceneColor;

                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular * pow(nDotV, 76.8);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }
                else
                {
                    // Define new render color
                    lighting_color = renderColor;
                }

                return lighting_color;
            }

            void main()
            {
                vec4 renderColor = vec4(ratio, ratio, ratio, 1.0) * vec4(color, 1.0);
                gl_FragColor = computeRenderColor(renderColor);
            }
        >>
    shader_set lights := lights_mask
    shader_set color  := (PLASTIC_R; PLASTIC_G; PLASTIC_B)

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera      := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set modelMatrix := (model_matrix at 1; model_matrix at 2; model_matrix at 3; model_matrix at 4;
                               model_matrix at 5; model_matrix at 6; model_matrix at 7; model_matrix at 8;
                               model_matrix at 9; model_matrix at 10; model_matrix at 11; model_matrix at 12;
                               model_matrix at 13; model_matrix at 14; model_matrix at 15; model_matrix at 16)

plastic_shader_no_lights ->
    /**
    * Define plastic shader with no lights supported.
    **/
    shader_program
        vertex_shader <<
            uniform vec3 camera;
            uniform mat4 modelMatrix;

            varying float ratio;
            void main()
            {
               gl_Position = ftransform();

               mat3 normalMatrix;

               // First column
               normalMatrix[0][0] = modelMatrix[0][0];
               normalMatrix[0][1] = modelMatrix[0][1];
               normalMatrix[0][2] = modelMatrix[0][2];

               // Second column
               normalMatrix[1][0] = modelMatrix[1][0];
               normalMatrix[1][1] = modelMatrix[1][1];
               normalMatrix[1][2] = modelMatrix[1][2];

               // Third column
               normalMatrix[2][0] = modelMatrix[2][0];
               normalMatrix[2][1] = modelMatrix[2][1];
               normalMatrix[2][2] = modelMatrix[2][2];


               // World-space lighting
               vec3 worldPos = vec3(modelMatrix * gl_Vertex);
               vec3 normal   = normalize (normalMatrix * gl_Normal);
               vec3 eyePos   = normalize(camera - worldPos);

               ratio = 0.5 * (1.0 + dot(eyePos, normal));
            }
        >>
        fragment_shader <<
            varying float ratio;
            uniform vec3 color;
            void main()
            {
                gl_FragColor = vec4(ratio * color, 1.0);
            }
        >>
        shader_set color := (PLASTIC_R; PLASTIC_G; PLASTIC_B)

        //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
        shader_set camera      := (camera_position at 1; camera_position at 2; camera_position at 3)
        shader_set modelMatrix := (model_matrix at 1; model_matrix at 2; model_matrix at 3; model_matrix at 4;
                                   model_matrix at 5; model_matrix at 6; model_matrix at 7; model_matrix at 8;
                                   model_matrix at 9; model_matrix at 10; model_matrix at 11; model_matrix at 12;
                                   model_matrix at 13; model_matrix at 14; model_matrix at 15; model_matrix at 16)


// -------------------------------------------------------------------------------------------------------------------
//   MARBLE MATERIAL
// -------------------------------------------------------------------------------------------------------------------

// First marble color
FIRST_MARBLE_R -> 1.0
FIRST_MARBLE_R := 1.0
FIRST_MARBLE_G -> 1.0
FIRST_MARBLE_G := 1.0
FIRST_MARBLE_B -> 1.0
FIRST_MARBLE_B := 1.0

// Second marble color
SECOND_MARBLE_R -> 0.6
SECOND_MARBLE_R := 0.6
SECOND_MARBLE_G -> 0.5
SECOND_MARBLE_G := 0.5
SECOND_MARBLE_B -> 0.5
SECOND_MARBLE_B := 0.5

// Size
MARBLE_SIZE -> 1.0
MARBLE_SIZE := 1.0

marble_first_color  r1:real, g1:real, b1:real ->
    /**
    * Set first color of marble material.
    **/
    FIRST_MARBLE_R  := r1
    FIRST_MARBLE_G  := g1
    FIRST_MARBLE_B  := b1

marble_second_color r2:real, g2:real, b2:real ->
    /**
    * Set second color of marble material.
    **/
    SECOND_MARBLE_R := r2
    SECOND_MARBLE_G := g2
    SECOND_MARBLE_B := b2

marble scale:real ->
    /**
    * Apply marble material.
    **/
    marble scale, 128

marble scale:real, seed:integer ->
    /**
    * Apply marble material.
    **/
    MARBLE_SIZE := scale

    // Default noise map 3D
    noise_map_3D 128, 128, seed

    // Rotation in order to enable pixel blur
    rotatex 0.05

    // Force activation of the texture
    // for object loader module
    sphere 0, 0, 0, 1.0e-007

    if SHADER4_AVAILABLE_MATERIALS = false then
        marble_shader_no_lights
    else
        marble_shader_lights

marble_shader_lights ->
    /**
    * Define marble shader with a full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            uniform float scale;

            varying vec3 viewDir;
            varying vec3 normal;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = scale * gl_Vertex / 100.0;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            uniform int       lights;
            uniform vec3      first_color;
            uniform vec3      second_color;
            uniform sampler3D noiseMap;

            varying vec3 viewDir;
            varying vec3 normal;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    // Get current scene color
                    ambient = gl_FrontLightModelProduct.sceneColor;

                    // Compute render for each enabled lights
                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular * pow(nDotV, 76.8);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }
                else
                {
                    // Get current scene color
                    ambient = gl_FrontLightModelProduct.sceneColor;

                    vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                    // Compute ambient part
                    ambient += vec4(0.0, 0.0, 0.0, 1.0);

                    // Diffuse coefficient
                    float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                    if (nDotL > 0.0)
                    {
                        // Compute diffuse part
                        diffuse += 0.6 * vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                        // Compute specular coefficient
                        float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                        if (nDotV > 0.0)
                        {
                            // Compute specular part
                            specular += 0.4 * vec4(1.0, 1.0, 1.0, 1.0) * pow(nDotV, 76.8);
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;

                }

                return lighting_color;
            }

            void main()
            {
                float scaling    = 1.0;
                float turbulence = 0.0;
                vec3 texCoord    = vec3(0.0);

                // Use 5 octaves for a better result
                for (int i = 0; i < 5; i++)
                {
                    texCoord    = (0.15 / scaling) * gl_TexCoord[0].xyz;
                    turbulence += scaling * (texture3D(noiseMap, texCoord).z - 0.5);
                    scaling    *= 0.4;
                }

                // Compute ratio according to turbulence
                float ratio = exp(-5.0 * abs(turbulence));

                // Compute final color
                vec3 mainColor = mix(first_color, second_color, ratio);
                gl_FragColor = computeRenderColor(vec4(mainColor, 1.0));
            }
        >>        
    shader_set noiseMap     := texture_unit                                        // Unit of the noise map
    shader_set lights       := lights_mask                                         // Bitmask of supported lights
    shader_set scale        := MARBLE_SIZE                                         // Size of material
    shader_set first_color  := (FIRST_MARBLE_R, FIRST_MARBLE_G, FIRST_MARBLE_B)    // First color of the material
    shader_set second_color := (SECOND_MARBLE_R, SECOND_MARBLE_G, SECOND_MARBLE_B) // Second color of the material

marble_shader_no_lights ->
    /**
    * Define marble shader with no support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;

            uniform float scale;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates with a scaling factor
                gl_TexCoord[0] = scale * gl_Vertex / 100.0;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);
            }
        >>
        fragment_shader <<
            uniform vec3      first_color;
            uniform vec3      second_color;
            uniform sampler3D noiseMap;

            varying vec3 viewDir;
            varying vec3 normal;

            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                // Get current scene color
                ambient = gl_FrontLightModelProduct.sceneColor;

                vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                // Compute ambient part
                ambient += vec4(0.0, 0.0, 0.0, 1.0);

                // Diffuse coefficient
                float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                if (nDotL > 0.0)
                {
                    // Compute diffuse part
                    diffuse += 0.6 * vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                    // Compute specular coefficient
                    float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                    if (nDotV > 0.0)
                    {
                        // Compute specular part
                        specular += 0.4 * vec4(1.0, 1.0, 1.0, 1.0) * pow(nDotV, 76.8);
                    }
                }

                 // Define new render color
                lighting_color  = (ambient + diffuse) * renderColor + specular;

                return lighting_color;
            }

            void main()
            {
                float scaling    = 1.0;
                float turbulence = 0.0;
                vec3 texCoord    = vec3(0.0);

                // Use 5 octaves for a better result
                for (int i = 0; i < 5; i++)
                {
                    texCoord    = (0.15 / scaling) * gl_TexCoord[0].xyz;
                    turbulence += scaling * (texture3D(noiseMap, texCoord).z - 0.5);
                    scaling    *= 0.4;
                }

                // Compute ratio according to turbulence
                float ratio = exp(-5.0 * abs(turbulence));

                // Compute final color
                vec3 mainColor = mix(first_color, second_color, ratio);
                gl_FragColor = computeRenderColor(vec4(mainColor, 1.0));
            }
        >>
    shader_set noiseMap     := texture_unit                                        // Unit of the noise map
    shader_set scale        := MARBLE_SIZE                                         // Size of material
    shader_set first_color  := (FIRST_MARBLE_R, FIRST_MARBLE_G, FIRST_MARBLE_B)    // First color of the material
    shader_set second_color := (SECOND_MARBLE_R, SECOND_MARBLE_G, SECOND_MARBLE_B) // Second color of the material

// -------------------------------------------------------------------------------------------------------------------
//   GRANITE MATERIAL
// -------------------------------------------------------------------------------------------------------------------

// First granite color
FIRST_GRANITE_R -> 0.30
FIRST_GRANITE_R := 0.30
FIRST_GRANITE_G -> 0.15
FIRST_GRANITE_G := 0.15
FIRST_GRANITE_B -> 0.10
FIRST_GRANITE_B := 0.10

// Second granite color
SECOND_GRANITE_R -> 0.80
SECOND_GRANITE_R := 0.80
SECOND_GRANITE_G -> 0.73
SECOND_GRANITE_G := 0.73
SECOND_GRANITE_B -> 0.71
SECOND_GRANITE_B := 0.71

// third granite color
THIRD_GRANITE_R -> 0.2
THIRD_GRANITE_R := 0.2
THIRD_GRANITE_G -> 0.2
THIRD_GRANITE_G := 0.2
THIRD_GRANITE_B -> 0.2
THIRD_GRANITE_B := 0.2

// Size
GRANITE_SIZE -> 1.0
GRANITE_SIZE := 1.0

granite_first_color  r1:real, g1:real, b1:real ->
    /**
    * Set first color of granite material.
    **/
    FIRST_GRANITE_R  := r1
    FIRST_GRANITE_G  := g1
    FIRST_GRANITE_B  := b1

granite_second_color r2:real, g2:real, b2:real ->
    /**
    * Set second color of granite material.
    **/
    SECOND_GRANITE_R := r2
    SECOND_GRANITE_G := g2
    SECOND_GRANITE_B := b2

granite_third_color r1:real, g1:real, b1:real ->
    /**
    * Set third color of granite material.
    **/
    THIRD_GRANITE_R  := r1
    THIRD_GRANITE_G  := g1
    THIRD_GRANITE_B  := b1

granite scale:real ->
    /**
    * Apply default granite material.
    **/
    granite scale, 128

granite scale:real, seed:integer ->
    /**
    * Apply granite material.
    **/
    GRANITE_SIZE := scale

    // Default noise map 3D
    noise_map_3D 128, 128, seed

    // Rotation in order to enable pixel blur
    rotatex 0.05

    // Force activation of the texture
    // for object loader module
    sphere 0, 0, 0, 1.0e-007

    if SHADER4_AVAILABLE_MATERIALS = false then
        granite_shader_no_lights
    else
        granite_shader_lights

granite_shader_lights ->
    /**
    * Define granite shader with full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;

            uniform float scale;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = scale * gl_Vertex / 100.0;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require
            uniform int       lights;
            uniform vec3      first_color;
            uniform vec3      second_color;
            uniform vec3      third_color;
            uniform sampler3D noiseMap;

            varying vec3 viewDir;
            varying vec3 normal;
            /**
            * Compute render color according to materials,
            * which are lights and colors parameters
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    // Get current scene color
                    ambient = gl_FrontLightModelProduct.sceneColor;

                    // Compute render for each enabled lights
                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular * pow(nDotV, 76.8);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }
                else
                {
                    // Get current scene color
                    ambient = gl_FrontLightModelProduct.sceneColor;

                    vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                    // Compute ambient part
                    ambient += vec4(0.0, 0.0, 0.0, 1.0);

                    // Diffuse coefficient
                    float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                    if (nDotL > 0.0)
                    {
                        // Compute diffuse part
                        diffuse += 0.5 * vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                        // Compute specular coefficient
                        float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                        if (nDotV > 0.0)
                        {
                            // Compute specular part
                            specular += 0.4 * vec4(1.0, 1.0, 1.0, 1.0) * pow(nDotV, 76.8);
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;

                }

                return lighting_color;
            }

            void main()
            {
                float scaling    = 1.0;
                vec2 turbulence  = vec2(0.0, 0.0);
                vec3 texCoord    = vec3(0.0);

                // Use 5 octaves for a better result
                for (int i = 0; i < 5; i++)
                {
                    texCoord    = (0.15 / scaling) * gl_TexCoord[0].xyz;
                    turbulence += scaling * (texture3D(noiseMap, texCoord).yz - 0.5);
                    scaling    *= 0.4;
                }

                // Compute vein ratio
                float veinRatio = clamp(5.0 * (0.5 + turbulence.x) - 1.5, 0.0, 1.0);

                // Compute final ratio
                float ratio = 5.0 * abs(turbulence.y);

                vec3 mainColor = mix(first_color, mix(third_color, second_color, veinRatio), ratio);
                gl_FragColor = computeRenderColor(vec4(mainColor, 1.0));
            }
        >>
    shader_set noiseMap     := texture_unit                                           // Unit of the noise map
    shader_set lights       := lights_mask                                            // Bitmask of supported lights
    shader_set scale        := GRANITE_SIZE                                           // Size of material
    shader_set first_color  := (FIRST_GRANITE_R, FIRST_GRANITE_G, FIRST_GRANITE_B)    // First color of the material
    shader_set second_color := (SECOND_GRANITE_R, SECOND_GRANITE_G, SECOND_GRANITE_B) // Second color of the material
    shader_set third_color  := (THIRD_GRANITE_R, THIRD_GRANITE_G, THIRD_GRANITE_B)    // Third color of the material

granite_shader_no_lights ->
    /**
    * Define granite shader with no support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;

            uniform float scale;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = scale * gl_Vertex / 100.0;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);
            }
        >>
        fragment_shader <<
            uniform vec3      first_color;
            uniform vec3      second_color;
            uniform vec3      third_color;
            uniform sampler3D noiseMap;

            varying vec3 viewDir;
            varying vec3 normal;

            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                // Get current scene color
                ambient = gl_FrontLightModelProduct.sceneColor;

                vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                // Compute ambient part
                ambient += vec4(0.0, 0.0, 0.0, 1.0);

                // Diffuse coefficient
                float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                if (nDotL > 0.0)
                {
                    // Compute diffuse part
                    diffuse += 0.5 * vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                    // Compute specular coefficient
                    float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                    if (nDotV > 0.0)
                    {
                        // Compute specular part
                        specular += 0.4 * vec4(1.0, 1.0, 1.0, 1.0) * pow(nDotV, 76.8);
                    }
                }

                 // Define new render color
                lighting_color  = (ambient + diffuse) * renderColor + specular;

                return lighting_color;
            }

            void main()
            {
                float scaling    = 1.0;
                vec2 turbulence  = vec2(0.0, 0.0);
                vec3 texCoord    = vec3(0.0);

                // Use 5 octaves for a better result
                for (int i = 0; i < 5; i++)
                {
                    texCoord    = (0.15 / scaling) * gl_TexCoord[0].xyz;
                    turbulence += scaling * (texture3D(noiseMap, texCoord).yz - 0.5);
                    scaling    *= 0.4;
                }

                // Compute vein ratio
                float veinRatio = clamp(5.0 * (0.5 + turbulence.y) - 1.5, 0.0, 1.0);

                // Compute final ratio
                float ratio = 5.0 * abs(turbulence.x);

                vec3 mainColor = mix(first_color, mix(third_color, second_color, veinRatio), ratio);
                gl_FragColor = computeRenderColor(vec4(mainColor, 1.0));
            }
        >>
    shader_set noiseMap     := texture_unit                                           // Unit of the noise map
    shader_set scale        := GRANITE_SIZE                                           // Size of material
    shader_set first_color  := (FIRST_GRANITE_R, FIRST_GRANITE_G, FIRST_GRANITE_B)    // First color of the material
    shader_set second_color := (SECOND_GRANITE_R, SECOND_GRANITE_G, SECOND_GRANITE_B) // Second color of the material
    shader_set third_color  := (THIRD_GRANITE_R, THIRD_GRANITE_G, THIRD_GRANITE_B)    // Third color of the material

// -------------------------------------------------------------------------------------------------------------------
//   WOOD MATERIAL
// -------------------------------------------------------------------------------------------------------------------

// First wood color
FIRST_WOOD_R -> 0.92
FIRST_WOOD_R := 0.92
FIRST_WOOD_G -> 0.51
FIRST_WOOD_G := 0.51
FIRST_WOOD_B -> 0.13
FIRST_WOOD_B := 0.13

// Second wood color
SECOND_WOOD_R -> 0.44
SECOND_WOOD_R := 0.44
SECOND_WOOD_G -> 0.21
SECOND_WOOD_G := 0.21
SECOND_WOOD_B -> 0.0
SECOND_WOOD_B := 0.0

// Size of the material
WOOD_SIZE -> 1.0
WOOD_SIZE := 1.0

// Ratio of the noise
NOISE_RATIO -> 1.0
NOISE_RATIO := 1.0

// Ratio of the noise
RING_SIZE -> 1.0
RING_SIZE := 1.0

wood_first_color r1:real, g1:real, b1:real ->
    /**
    * Set first color of wood material.
    **/
    FIRST_WOOD_R  := r1
    FIRST_WOOD_G  := g1
    FIRST_WOOD_B  := b1

wood_second_color r2:real, g2:real, b2:real ->
    /**
    * Set second color of wood material.
    **/
    SECOND_WOOD_R := r2
    SECOND_WOOD_G := g2
    SECOND_WOOD_B := b2

wood scale:real ->
    /**
    * Apply wood material.
    **/
    wood scale, 20.0, 0.87, 128

wood scale:real, ring:real, noise:real, seed:integer ->
    /**
    * Apply wood material.
    **/
    WOOD_SIZE   := scale
    RING_SIZE   := ring
    NOISE_RATIO := noise

    // Default noise map 3D
    noise_map_3D 128, 128, seed

    // Rotation in order to enable pixel blur
    rotatex 0.05

    // Force activation of the texture
    // for object loader module
    sphere 0, 0, 0, 1.0e-007

    if SHADER4_AVAILABLE_MATERIALS = false then
        wood_shader_no_lights
    else
        wood_shader_lights


wood_shader_lights ->
    /**
    * Define wood shader with a full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;

            uniform float scale;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = scale * gl_Vertex / 100.0;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            uniform vec3      first_color;
            uniform vec3      second_color;
            uniform sampler3D noiseMap;
            uniform float     noiseRatio;
            uniform float     ringSize;

            uniform int       lights;

            varying vec3 viewDir;
            varying vec3 normal;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    // Get current scene color
                    ambient = gl_FrontLightModelProduct.sceneColor;

                    // Compute render for each enabled lights
                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular * pow(nDotV, 76.8);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }
                else
                {
                    // Get current scene color
                    ambient = gl_FrontLightModelProduct.sceneColor;

                    vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                    // Compute ambient part
                    ambient += vec4(0.0, 0.0, 0.0, 1.0);

                    // Diffuse coefficient
                    float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                    if (nDotL > 0.0)
                    {
                        // Compute diffuse part
                        diffuse += 0.5 * vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                        // Compute specular coefficient
                        float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                        if (nDotV > 0.0)
                        {
                            // Compute specular part
                            specular += 0.4 * vec4(1.0, 1.0, 1.0, 1.0) * pow(nDotV, 76.8);
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;

                }

                return lighting_color;
            }

            void main()
            {
               vec3 texCoord = 0.5 * gl_TexCoord[0].xyz;
               float noise   = texture3D(noiseMap, texCoord).x - 1.0;

               // Define some rings of the wood
               float r = fract(ringSize * gl_TexCoord[0].z + noiseRatio * noise);

               float sharp = 20.0;
               float ring  = (r - pow(r, sharp));

               // Add noise
               float ratio = ring + noise;

               vec3 mainColor = mix(first_color, second_color, ratio);
               gl_FragColor   = computeRenderColor(vec4(mainColor, 1.0));
            }
        >>
    shader_set noiseMap     := texture_unit                                  // Unit of the noise map
    shader_set lights       := lights_mask                                   // Bitmask of supported lights
    shader_set noiseRatio   := NOISE_RATIO                                   // Ratio of noise in the material
    shader_set ringSize     := RING_SIZE                                     // Size of rings in the material
    shader_set scale        := WOOD_SIZE                                     // Size of material
    shader_set first_color  := (FIRST_WOOD_R, FIRST_WOOD_G, FIRST_WOOD_B)    // First color of the material
    shader_set second_color := (SECOND_WOOD_R, SECOND_WOOD_G, SECOND_WOOD_B) // Second color of the material

wood_shader_no_lights ->
    /**
    * Define wood shader with no support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<

            varying vec3 viewDir;
            varying vec3 normal;
            uniform float scale;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = scale * gl_Vertex / 100.0;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);
            }
        >>
        fragment_shader <<
            uniform vec3      first_color;
            uniform vec3      second_color;
            uniform sampler3D noiseMap;
            uniform float     noiseRatio;
            uniform float     ringSize;

            varying vec3 viewDir;
            varying vec3 normal;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                // Get current scene color
                ambient = gl_FrontLightModelProduct.sceneColor;

                vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                // Compute ambient part
                ambient += vec4(0.0, 0.0, 0.0, 1.0);

                // Diffuse coefficient
                float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                if (nDotL > 0.0)
                {
                    // Compute diffuse part
                    diffuse += 0.5 * vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                    // Compute specular coefficient
                    float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                    if (nDotV > 0.0)
                    {
                        // Compute specular part
                        specular += 0.4 * vec4(1.0, 1.0, 1.0, 1.0) * pow(nDotV, 76.8);
                    }
                }

                 // Define new render color
                lighting_color  = (ambient + diffuse) * renderColor + specular;

                return lighting_color;
            }

            void main()
            {
               vec3 texCoord = 0.5 * gl_TexCoord[0].xyz;
               float noise   = texture3D(noiseMap, texCoord).x - 1.0;

               // Define some rings of the wood
               float r = fract(ringSize * gl_TexCoord[0].z + noiseRatio * noise);

               float sharp = 20.0;
               float ring  = (r - pow(r, sharp));

               // Add noise
               float ratio = ring + noise;

               vec3 mainColor = mix(first_color, second_color, ratio);
               gl_FragColor   = computeRenderColor(vec4(mainColor, 1.0));
            }
        >>
    shader_set noiseMap     := texture_unit                                  // Unit of the noise map
    shader_set noiseRatio   := NOISE_RATIO                                   // Ratio of noise in the material
    shader_set ringSize     := RING_SIZE                                     // Size of rings in the material
    shader_set scale        := WOOD_SIZE                                     // Size of material
    shader_set first_color  := (FIRST_WOOD_R, FIRST_WOOD_G, FIRST_WOOD_B)    // First color of the material
    shader_set second_color := (SECOND_WOOD_R, SECOND_WOOD_G, SECOND_WOOD_B) // Second color of the material


// -------------------------------------------------------------------------------------------------------------------
//   FRESNEL MATERIAL
// -------------------------------------------------------------------------------------------------------------------

// Material roughness
FRESNEL_ROUGHNESS -> 1.0
FRESNEL_ROUGHNESS := 1.0

// Indice of refraction
FRESNEL_REFRACTION -> 1.0
FRESNEL_REFRACTION := 1.0

// Material ratio bending
FRESNEL_RATIO -> 0.0
FRESNEL_RATIO := 1.0


fresnel_material r:real, n:real, roughness:real ->
    /**
    * Apply a fresnel material.
    **/
    FRESNEL_RATIO := r
    FRESNEL_REFRACTION := n
    FRESNEL_ROUGHNESS  := roughness

    // This trick enables blur on pixels of the result texture
    rotatex 0.05
    rotatex -0.05

    if SHADER4_AVAILABLE_MATERIALS = false then
        fresnel_shader_no_lights
    else
        fresnel_shader_lights

fresnel_shader_lights ->
    /**
    * Define shader for fresnel material with full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            #extension GL_EXT_gpu_shader4 : require

            uniform vec3 camera;
            uniform mat4 modelMatrix;

            varying vec3 normalWorld;
            varying vec3 viewWorld;

            varying vec3 normal;
            varying vec3 viewDir;

            void main()
            {
               mat3 normalMatrix;

               // First column
               normalMatrix[0][0] = modelMatrix[0][0];
               normalMatrix[0][1] = modelMatrix[0][1];
               normalMatrix[0][2] = modelMatrix[0][2];

               // Second column
               normalMatrix[1][0] = modelMatrix[1][0];
               normalMatrix[1][1] = modelMatrix[1][1];
               normalMatrix[1][2] = modelMatrix[1][2];

               // Third column
               normalMatrix[2][0] = modelMatrix[2][0];
               normalMatrix[2][1] = modelMatrix[2][1];
               normalMatrix[2][2] = modelMatrix[2][2];

               gl_Position = ftransform();

               // World-space
               vec3 eyePos = vec3(gl_TextureMatrix[0] * modelMatrix * gl_Vertex);
               normalWorld = normalize(normalMatrix * gl_Normal);
               viewWorld   = normalize(eyePos - camera);

               // Eye-space
               eyePos  = (gl_ModelViewMatrix * gl_Vertex).xyz;
               normal  = normalize(gl_NormalMatrix * gl_Normal);
               viewDir = normalize(-eyePos);
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            // Material parameters
            uniform float IoR; // Index of refraction
            uniform float ratio;
            uniform float roughness;
            uniform samplerCube environmentMap;

            uniform int  lights;

            varying vec3 normalWorld;
            varying vec3 viewWorld;

            varying vec3 normal;
            varying vec3 viewDir;

            const float roughness_ratio = 50.0;

            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene (Lambertian model).
            **/
            vec4 computeRenderColor()
            {                           
                // Define a maximum of lights supported
                int MAX_LIGHTS = 8;

                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                if(lights > 0)
                {
                    ambient = gl_FrontLightModelProduct.sceneColor
                            * gl_FrontMaterial.ambient;

                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient
                                     * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse
                                         * gl_FrontMaterial.diffuse
                                         * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = ambient + diffuse + specular;
                }
                else
                {
                    // We define a default light in case there are no one defined.
                    vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                    // Compute ambient part
                    ambient = gl_FrontMaterial.ambient;

                    // Diffuse coefficient
                    float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                    if (nDotL > 0.0)
                    {
                        // Compute diffuse part
                        diffuse = gl_FrontMaterial.diffuse * nDotL;

                        // Compute specular coefficient
                        float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                        if (nDotV > 0.0)
                        {
                            // Compute specular part
                            specular = gl_FrontMaterial.specular
                                     * pow(nDotV, gl_FrontMaterial.shininess);
                        }
                    }

                     // Define new render color
                    lighting_color = ambient + diffuse + specular;
                }

                return lighting_color;
            }


            void main()
            {
                // Harmonization of the index of refraction
                float Eta = 0.086 * IoR + 0.93;

                vec3 reflectDir, refractDir;
                reflectDir = normalize(reflect(viewWorld, normalWorld));
                refractDir = normalize(refract(viewWorld, normalWorld, Eta));

                vec3 reflectColor, refractColor;
                reflectColor = textureCube(environmentMap, reflectDir).xyz;
                refractColor = textureCube(environmentMap, refractDir).xyz;

                // Compute fresnel ratio
                float fresnel = 0.1 + 2.0 * pow(1.0 + (dot(viewWorld, normalWorld)),
                                                1.0 / (roughness * roughness_ratio));

                // Compute final color
                vec3 fresnelColor = mix(refractColor, reflectColor, clamp(fresnel, 0.0, 1.0));
                vec3 renderColor  = computeRenderColor().rgb;
                vec3 finalColor   = mix(fresnelColor, renderColor, ratio);


                gl_FragColor  = vec4(finalColor, 1.0);
            }
        >>

    shader_set IoR            := FRESNEL_REFRACTION
    shader_set ratio          := FRESNEL_RATIO
    shader_set roughness      := FRESNEL_ROUGHNESS
    shader_set environmentMap := texture_unit
    shader_set lights         := lights_mask

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera         := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set modelMatrix    := (model_matrix at 1;  model_matrix at 2;  model_matrix at 3;  model_matrix at 4;
                                  model_matrix at 5;  model_matrix at 6;  model_matrix at 7;  model_matrix at 8;
                                  model_matrix at 9;  model_matrix at 10; model_matrix at 11; model_matrix at 12;
                                  model_matrix at 13; model_matrix at 14; model_matrix at 15; model_matrix at 16)

fresnel_shader_no_lights ->
    /**
    * Define shader for fresnel material with no support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            uniform vec3 camera;
            uniform mat4 modelMatrix;

            varying vec3 normalWorld;
            varying vec3 viewWorld;

            varying vec3 normal;
            varying vec3 viewDir;
            void main()
            {
               mat3 normalMatrix;

               // First column
               normalMatrix[0][0] = modelMatrix[0][0];
               normalMatrix[0][1] = modelMatrix[0][1];
               normalMatrix[0][2] = modelMatrix[0][2];

               // Second column
               normalMatrix[1][0] = modelMatrix[1][0];
               normalMatrix[1][1] = modelMatrix[1][1];
               normalMatrix[1][2] = modelMatrix[1][2];

               // Third column
               normalMatrix[2][0] = modelMatrix[2][0];
               normalMatrix[2][1] = modelMatrix[2][1];
               normalMatrix[2][2] = modelMatrix[2][2];

               gl_Position = ftransform();

               // World-space
               vec3 eyePos   = vec3(gl_TextureMatrix[0] * modelMatrix * gl_Vertex);
               normalWorld   = normalize(normalMatrix * gl_Normal);
               viewWorld     = normalize(eyePos - camera);

               // Eye-space
               eyePos  = (gl_ModelViewMatrix * gl_Vertex).xyz;
               normal  = normalize(gl_NormalMatrix * gl_Normal);
               viewDir = normalize(-eyePos);
            }
        >>
        fragment_shader <<
            // Material parameters
            uniform float IoR; // Index of refraction
            uniform float ratio;
            uniform float roughness;
            uniform samplerCube environmentMap;

            varying vec3 normalWorld;
            varying vec3 viewWorld;

            varying vec3 normal;
            varying vec3 viewDir;

            const float roughness_ratio = 50.0;

            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor()
            {
                vec4 lighting_color;
                vec3 N = normalize(normal);
                vec3 V = normalize(viewDir);

                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                // We define a default light in case there are no one defined.
                vec3 L = normalize(vec3(0.0, 0.0, 50.0));

                // Compute ambient part
                ambient = gl_FrontMaterial.ambient;

                // Diffuse coefficient
                float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                if (nDotL > 0.0)
                {
                    // Compute diffuse part
                    diffuse = gl_FrontMaterial.diffuse * nDotL;

                    // Compute specular coefficient
                    float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                    if (nDotV > 0.0)
                    {
                        // Compute specular part
                        specular = gl_FrontMaterial.specular
                                 * pow(nDotV, gl_FrontMaterial.shininess);
                    }
                }

                lighting_color = ambient + diffuse + specular;

                return lighting_color;
            }

            void main()
            {
                // Harmonization of the index of refraction
                float Eta = 0.086 * IoR + 0.93;

                vec3 reflectDir, refractDir;
                reflectDir = normalize(reflect(viewWorld, normalWorld));
                refractDir = normalize(refract(viewWorld, normalWorld, Eta));

                vec3 reflectColor, refractColor;
                reflectColor = textureCube(environmentMap, reflectDir).xyz;
                refractColor = textureCube(environmentMap, refractDir).xyz;

                // Compute fresnel ratio
                float fresnel = 0.1 + 2.0 * pow(1.0 - (dot(-viewWorld, normalWorld)),
                                                1.0 / (roughness * roughness_ratio));

                // Compute final color
                vec3 fresnelColor = mix(refractColor, reflectColor, fresnel);
                vec3 renderColor  = computeRenderColor().rgb;
                vec3 finalColor   = mix(fresnelColor, renderColor, ratio);

                 // Define new render color
                gl_FragColor = vec4(finalColor, 1.0);
            }
        >>

    shader_set IoR            := FRESNEL_REFRACTION
    shader_set ratio          := FRESNEL_RATIO
    shader_set roughness      := FRESNEL_ROUGHNESS
    shader_set environmentMap := texture_unit

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera         := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set modelMatrix    := (model_matrix at 1;  model_matrix at 2;  model_matrix at 3;  model_matrix at 4;
                                  model_matrix at 5;  model_matrix at 6;  model_matrix at 7;  model_matrix at 8;
                                  model_matrix at 9;  model_matrix at 10; model_matrix at 11; model_matrix at 12;
                                  model_matrix at 13; model_matrix at 14; model_matrix at 15; model_matrix at 16)

// -------------------------------------------------------------------------------------------------------------------
//   GLASS MATERIAL
// -------------------------------------------------------------------------------------------------------------------

glass ->
    /**
    * Define a sort of glass material.
    **/
    material_ambient 0.0, 0.0, 0.0, 0.0
    material_diffuse 0.588235, 0.670588, 0.729412, 1.0
    material_specular 0.9, 0.9, 0.9, 1.0
    material_shininess 96.0
    fresnel_material 0.2, 1.12, 0.01

// -------------------------------------------------------------------------------------------------------------------
//   BRONZE MATERIAL
// -------------------------------------------------------------------------------------------------------------------

bronze ->
    /**
    * Define a sort of bronze material.
    **/
    material_ambient 0.2125, 0.1275, 0.054, 1.0
    material_diffuse 0.714, 0.4284, 0.18144, 1.0
    material_specular 0.3935, 0.2719, 0.1667, 1.0
    material_shininess 25.6
    fresnel_material 0.93, 1.18, 10.0

// -------------------------------------------------------------------------------------------------------------------
//   SILVER MATERIAL
// -------------------------------------------------------------------------------------------------------------------

silver ->
    /**
    * Define a sort of silver material.
    **/
    material_ambient 0.19225, 0.19225, 0.19225, 1.0
    material_diffuse 0.50754, 0.50754, 0.50754, 1.0
    material_specular 0.508273, 0.508273, 0.508273, 1.0
    material_shininess 51.2
    fresnel_material 0.7, 0.8, 10.0

// -------------------------------------------------------------------------------------------------------------------
//   GOLD MATERIAL
// -------------------------------------------------------------------------------------------------------------------

gold ->
    /**
    * Define a sort of gold material.
    **/
    material_ambient 0.24725, 0.1995, 0.0745, 1.0
    material_diffuse 0.75164, 0.60648, 0.22648, 1.0
    material_specular 0.628281, 0.555802, 0.366065, 1.0
    material_shininess 51.2
    fresnel_material 0.7, 0.47, 10.0

// -------------------------------------------------------------------------------------------------------------------
//   IRON MATERIAL
// -------------------------------------------------------------------------------------------------------------------

iron ->
    /**
    * Define a sort of iron material.
    **/
    material_ambient 0.19225, 0.19225, 0.19225, 1.0
    material_diffuse 0.43, 0.376, 0.364, 1.0
    material_specular 0.508273, 0.508273, 0.508273, 1.0
    material_shininess 51.2
    fresnel_material 0.6, 2.95, 1.0

// -------------------------------------------------------------------------------------------------------------------
//   CHROMIUM MATERIAL
// -------------------------------------------------------------------------------------------------------------------

chrome  ->
    /**
    * Define a sort of chrome material.
    **/
    material_ambient 0.25, 0.25, 0.25, 1.0
    material_diffuse 0.4, 0.4, 0.4, 1.0
    material_specular 0.774597, 0.774597, 0.774597, 1.0
    material_shininess 76.8
    fresnel_material 0.35, 2.705, 10.0

// -------------------------------------------------------------------------------------------------------------------
//   WATER MATERIAL
// -------------------------------------------------------------------------------------------------------------------

water ->
    /**
    * Define a sort of water material.
    **/
    material_ambient 0.0, 0.0, 0.0, 0.0
    material_diffuse  0.35, 0.5, 0.5, 1.0
    material_specular 0.9, 0.9, 0.9, 1.0
    material_shininess 76.8
    fresnel_material 0.5, 1.325, 0.01

// -------------------------------------------------------------------------------------------------------------------
//   EMERALD MATERIAL
// -------------------------------------------------------------------------------------------------------------------

emerald ->
    /**
    * Define a sort of emerald material.
    **/
    material_ambient 0.0215, 0.1745, 0.0215, 0.55
    material_diffuse 0.07568, 0.61424, 0.07568, 0.55
    material_specular 0.633, 0.727811, 0.633, 0.55
    material_shininess 76.8
    fresnel_material 0.65, 1.56, 0.01

// -------------------------------------------------------------------------------------------------------------------
//   RUBY MATERIAL
// -------------------------------------------------------------------------------------------------------------------

ruby ->
    /**
    * Define a sort of ruby material.
    **/
    material_ambient 0.1745, 0.01175, 0.01175, 0.55
    material_diffuse 0.61424, 0.04136, 0.04136, 0.55
    material_specular 0.727811, 0.626959, 0.626959, 0.55
    material_shininess 76.8
    fresnel_material 0.65, 1.757, 0.01

// -------------------------------------------------------------------------------------------------------------------
//   JADE MATERIAL
// -------------------------------------------------------------------------------------------------------------------

jade ->
    /**
    * Define a sort of jade material.
    **/
    material_ambient 0.135, 0.2225, 0.1575, 0.95
    material_diffuse 0.54, 0.89, 0.63, 0.95
    material_specular 0.316228, 0.316228, 0.316228, 0.95
    material_shininess 12.8
    fresnel_material 0.7, 1.64, 10.0

